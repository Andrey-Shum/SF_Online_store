[MAIN]

# Анализируйте резервные блоки импорта. Это можно использовать для поддержки как Python 2, так и
# 3 совместимый код, что означает, что блок может иметь существующий код.
# только в том или ином интерпретаторе, что приводит к ложным срабатываниям при анализе.
analyse-fallback-blocks=no

# Очистите кэши в памяти после завершения проверки. Полезно при запуске pylint
# в серверном режиме.
clear-cache-post-run=no

# Загрузите и включите все доступные расширения. Используйте --list-extensions, чтобы просмотреть список
# все доступные расширения.
#enable-all-extensions=

# В режиме ошибки сообщения с категорией, кроме ERROR или FATAL,
# подавлено, и по умолчанию отчеты не создаются. Режим ошибки совместим с
# отключение определенных ошибок.
#errors-only=

# Всегда возвращайте код состояния 0 (отсутствие ошибок), даже если обнаружены ошибки lint.
# Это в первую очередь полезно в сценариях непрерывной интеграции.
#exit-zero=

# Список имен пакетов или модулей, разделенных запятыми, из которых могут использоваться расширения C.
# быть загружен. Расширения загружаются в активный интерпретатор Python и могут
# запускаем произвольный код.
extension-pkg-allow-list=

# Список имен пакетов или модулей, разделенных запятыми, из которых могут использоваться расширения C.
# быть загружен. Расширения загружаются в активный интерпретатор Python и могут
# запускаем произвольный код. (Это альтернативное имя extension-pkg-allow-list.
# для обратной совместимости.)
extension-pkg-whitelist=

# Вернуть ненулевой код выхода, если обнаружено какое-либо из этих сообщений/категорий,
# даже если оценка выше значения --fail-under. Синтаксис такой же, как у Enable. Сообщения
# указанные включены, а категории проверяют только уже включенные сообщения.
fail-on=

# Укажите порог оценки, при котором программа закроется с ошибкой.
fail-under=10

# Интерпретируйте стандартный ввод как скрипт Python, имя файла которого необходимо передать как
# аргумент модуль_или_пакет.
#from-stdin=

# Файлы или каталоги, которые нужно пропустить. Это должны быть базовые имена, а не пути.
ignore=CVS, ven

# Добавляйте файлы или каталоги, соответствующие шаблонам регулярных выражений, в
# ignore-list. Регулярное выражение соответствует путям и может быть в Posix или Windows.
# формат. Поскольку '\\' представляет собой разделитель каталогов в системах Windows,
# его нельзя использовать в качестве escape-символа.
ignore-paths=venv

# Файлы или каталоги, соответствующие шаблонам регулярных выражений, пропускаются.
# Регулярное выражение соответствует базовым именам, а не путям. Значение по умолчанию игнорирует
# Блокировки файлов Emacs
ignore-patterns=^\.#

# Список имен модулей, атрибуты членов которых не следует проверять
# (полезно для modules/projects, в которых пространства имен манипулируются во время выполнения
# и, следовательно, существующие атрибуты членов не могут быть выведены с помощью статического анализа). Это
# поддерживает квалифицированные имена модулей, а также сопоставление шаблонов Unix.
ignored-modules=

# Код Python для выполнения, обычно для манипуляций с sys.path, таких как
# pygtk.require().
#init-hook=

# Используйте несколько процессов для ускорения Pylint. Если указать 0, будет автоматически обнаружено
# количество процессоров, доступных для использования. В Windows их количество будет ограничено до
# избежать зависаний.
jobs=1

# Контролируйте количество потенциальных выведенных значений при выводе одного
# объект. Это может повысить производительность при работе с большими функциями или
# сложные вложенные условия.
limit-inference-results=100

# Список плагинов (в виде разделенных запятыми значений имен модулей Python) для загрузки,
# обычно для регистрации дополнительных шашек.
load-plugins=

# Пикл собрал данные для последующих сравнений.
persistent=yes

# Минимальная версия Python, используемая для проверок, зависящих от версии. По умолчанию будет
# версия, используемая для запуска pylint.
py-version=3.10

# Найдите модули и пакеты Python в поддереве файловой системы.
recursive=no

# Добавьте пути в список корней источника. Поддерживает шаблоны подстановки.
# корень источника — это абсолютный путь или путь относительно текущего рабочего
# каталог, используемый для определения пространства имен пакета для модулей, расположенных под
# корень источника.
source-roots=

# Если этот параметр включен, pylint будет пытаться угадать типичную неправильную конфигурацию и выдать
# user-friendly подсказки вместо false-positive сообщения об ошибках.
suggestion-mode=yes

# Разрешить загрузку произвольных расширений C. Расширения импортируются в
# активный интерпретатор Python и может запускать произвольный код.
unsafe-load-any-extension=no

# В подробном режиме будет отображаться дополнительная информация, не связанная с проверкой.
#verbose=


[BASIC]

# Стиль именования, соответствующий правильным именам аргументов.
argument-naming-style=snake_case

# Регулярное выражение, соответствующее правильным именам аргументов. Переопределения argument-
# naming-style. Если оставить пустым, имена аргументов будут сверяться с набором
# стиль именования.
#argument-rgx=

# Стиль именования соответствует правильным именам атрибутов.
attr-naming-style=snake_case

# Регулярное выражение, соответствующее правильным именам атрибутов. Переопределения attr-naming-
# style. Если оставить пустым, имена атрибутов будут сверяться с заданным именованием
# стиль.
#attr-rgx=

#Неправильные имена переменных, которые всегда следует отклонять, разделенные запятой.
bad-names=foo,
          bar,
          baz,
          toto,
          tutu,
          tata

# Неправильные имена переменных, регулярные выражения, разделенные запятой. Если имена соответствуют любому регулярному выражению,
# им всегда будет отказано
bad-names-rgxs=

# Стиль именования соответствует правильным именам атрибутов класса.
class-attribute-naming-style=any

# Регулярное выражение, соответствующее правильным именам атрибутов класса. Переопределения class-
# attribute-naming-style. Если оставить пустым, будут проверены имена атрибутов класса
# с заданным стилем именования.
#class-attribute-rgx=

# Стиль именования соответствует правильным именам констант класса.
class-const-naming-style=UPPER_CASE

# Регулярное выражение, соответствующее правильным именам констант класса. Переопределения class-
# const-naming-style. Если оставить пустым, имена констант класса будут проверены с помощью
# заданный стиль именования.
#class-const-rgx=

# Стиль именования соответствует правильным именам классов.
class-naming-style=PascalCase

# Регулярное выражение, соответствующее правильным именам классов. Переопределения class-naming-
# style. Если оставить пустым, имена классов будут сверяться с заданным стилем именования.
#class-rgx=

# Стиль именования, соответствующий правильным именам констант.
const-naming-style=UPPER_CASE

# Регулярное выражение, соответствующее правильным именам констант. Переопределения const-naming-
# style. Если оставить пустым, имена констант будут сверяться с заданными именами.
# стиль.
#const-rgx=

# Минимальная длина строки для функций/классов, которым требуются строки документации, короче
# из них освобождены от налога.
docstring-min-length=-1

# Стиль именования, соответствующий правильным именам функций.
function-naming-style=snake_case

# Регулярное выражение, соответствующее правильным именам функций. Переопределения function-
# naming-style. Если оставить пустым, имена функций будут сверяться с набором
# стиль именования.
#function-rgx=

# Хорошие имена переменных, которые всегда следует принимать, разделяются запятой.
good-names=i,
           j,
           k,
           ex,
           Run,
           _

# Хорошие имена переменных — регулярные выражения, разделенные запятой. Если имена соответствуют любому регулярному выражению,
# они всегда будут приняты
good-names-rgxs=

#Включите подсказку о правильном формате именования с помощью invalid-name.
include-naming-hint=no

# Стиль именования соответствует правильным встроенным именам итераций.
inlinevar-naming-style=any

# Регулярное выражение, соответствующее правильным встроенным именам итераций. Переопределения
# inlinevar-naming-style. Если оставить пустым, будут проверены встроенные имена итераций.
# с заданным стилем именования.
#inlinevar-rgx=

# Стиль именования соответствует правильным именам методов.
method-naming-style=snake_case

# Регулярное выражение, соответствующее правильным именам методов. Переопределения method-naming-
# style. Если оставить пустым, имена методов будут сверяться с заданным стилем именования.
#method-rgx=

# Стиль именования соответствует правильным именам модулей.
module-naming-style=snake_case

# Регулярное выражение, соответствующее правильным именам модулей. Переопределения module-naming-
# style. Если оставить пустым, имена модулей будут сверяться с заданным стилем именования.
#module-rgx=

# Colon-delimited наборы имен, которые определяют стиль именования друг друга, когда
# регулярные выражения имен допускают несколько стилей.
name-group=

# Регулярное выражение, которое должно соответствовать только именам функций или классов, которые соответствуют
# не требуется строка документации.
no-docstring-rgx=^_

# Список декораторов, которые создают свойства, такие как abc.abstractproperty. Добавлять
# в этот список, чтобы зарегистрировать другие декораторы, создающие действительные свойства.
# Эти декораторы принимаются во внимание только для invalid-name.
property-classes=abc.abstractproperty

# Регулярное выражение, соответствующее правильным именам псевдонимов типов. Если оставить пустым, введите
# имена псевдонимов будут проверены на соответствие заданному стилю именования.
#typealias-rgx=

# Регулярное выражение, соответствующее именам переменных правильного типа. Если оставить пустым, введите
# имена переменных будут проверены на соответствие заданному стилю именования.
#typevar-rgx=

# Стиль именования, соответствующий правильным именам переменных.
variable-naming-style=snake_case

# Регулярное выражение, соответствующее правильным именам переменных. Переопределения variable-
# naming-style. Если оставить пустым, имена переменных будут сверяться с набором
# стиль именования.
#variable-rgx=


[CLASSES]

# Предупреждать о доступе к защищенным атрибутам внутри специальных методов
check-protected-access-in-special-methods=no

# Список имен методов, используемых для объявления (т. е. назначения) атрибутов экземпляра.
defining-attr-methods=__init__,
                      __new__,
                      setUp,
                      asyncSetUp,
                      __post_init__

# Список имен участников, которые следует исключить из защищенного доступа
# предупреждение.
exclude-protected=_asdict,_fields,_replace,_source,_make,os._exit

# Список допустимых имен для первого аргумента метода класса.
valid-classmethod-first-arg=cls

# Список допустимых имен для первого аргумента в методе класса метакласса.
valid-metaclass-classmethod-first-arg=mcs


[DESIGN]

# Список регулярных выражений имен предков классов, которые следует игнорировать при подсчете
# публичные методы (см. R0903)
exclude-too-few-public-methods=

# Список полных имен классов, которые следует игнорировать при подсчете родительских классов (см.
# R0901)
ignored-parents=

# Максимальное количество аргументов для функции/метода.
max-args=5

# Максимальное количество атрибутов для класса (см. R0902).
max-attributes=7

# Максимальное количество логических выражений в операторе if (см. R0916).
max-bool-expr=5

# Максимальное количество ветвей для тела функции/метода.
max-branches=12

# Максимальное количество локальных переменных для тела функции/метода.
max-locals=15

# Максимальное количество родителей в классе (см. R0901).
max-parents=7

# Максимальное количество общедоступных методов для класса (см. R0904).
max-public-methods=20

# Максимальное количество возвратов/выходов для тела функции/метода.
max-returns=6

# Максимальное количество операторов в теле функции/метода.
max-statements=50

# Минимальное количество общедоступных методов для класса (см. R0903)..
min-public-methods=2


[EXCEPTIONS]

# Исключения, при обнаружении которых выдается предупреждение.
overgeneral-exceptions=builtins.BaseException,builtins.Exception


[FORMAT]

# Ожидаемый формат окончания строки, например. пустой (любое окончание строки), LF или CRLF.
expected-line-ending-format=

# Регулярное выражение для строки, длина которой может превышать ограничение.
ignore-long-lines=^\s*(# )?<?https?://\S+>?$

# Количество пробелов в отступе внутри висячей или непрерывной строки.
indent-after-paren=4

# Строка, используемая в качестве единицы отступа. Обычно это " " (4 пробела) или "\t" (1
# вкладка).
indent-string='    '

# Максимальное количество символов в одной строке.
max-line-length=120

# Максимальное количество строк в модуле.
max-module-lines=1000

# Разрешить размещение тела класса на той же строке, что и объявление, если тело
# содержит один оператор.
single-line-class-stmt=no

# Разрешить тело if находиться на той же строке, что и тест, если нет
# еще.
single-line-if-stmt=no


[IMPORTS]

# Список модулей, которые можно импортировать на любом уровне, а не только на верхнем уровне.
# один.
allow-any-import-level=

# Разрешить явный реэкспорт по псевдониму из пакета __init__.
allow-reexport-from-package=no

# Разрешить импорт подстановочных знаков из модулей, определяющих __all__.
allow-wildcard-with-all=no

# Устаревшие модули, которые не следует использовать, разделенные запятой.
deprecated-modules=

# Выведите график (.gv или любой поддерживаемый формат изображения) внешних зависимостей.
# в данный файл (отчет RP0402 отключать нельзя).
ext-import-graph=

# Выведите график (.gv или любой поддерживаемый формат изображения) всех (т.е. внутренних и
# внешние) зависимости от данного файла (отчет RP0402 не должен быть
# неполноценный).
import-graph=

# Выведите график (.gv или любой поддерживаемый формат изображения) внутренних зависимостей.
# в данный файл (отчет RP0402 отключать нельзя).
int-import-graph=

# Принудительный порядок импорта, чтобы распознать модуль как часть стандарта.
# библиотеки совместимости.
known-standard-library=

# Принудительный порядок импорта, чтобы распознать модуль как часть сторонней библиотеки.
known-third-party=enchant

# Пары модулей и предпочтительные модули, разделенные запятой.
preferred-modules=


[LOGGING]

# Тип форматирования строк, который выполняют методы журналирования. «старый» означает использование %
# форматирование, `new` предназначен для форматирования `{}`.
logging-format-style=old

# Модули журналирования для проверки наличия аргументов строкового формата в журнале.
# формат параметра функции.
logging-modules=logging


[MESSAGES CONTROL]

# Показывать предупреждения только с указанными уровнями достоверности. Оставьте пустым, чтобы показать
# все. Допустимые уровни: HIGH, CONTROL_FLOW, INFERENCE, INFERENCE_FAILURE,
# UNDEFINED.
confidence=HIGH,
           CONTROL_FLOW,
           INFERENCE,
           INFERENCE_FAILURE,
           UNDEFINED

# Отключите сообщение, отчет, категорию или средство проверки с указанными идентификаторами. Ты
# можно либо указать несколько идентификаторов, разделенных запятой (,), либо поместить это
# параметр несколько раз (только в командной строке, а не в конфигурации
# файл, где он должен появиться только один раз). Вы также можете использовать «--disable=all», чтобы
# сначала отключите все, а затем снова включите определенные проверки. Например, если
# вы хотите запустить только проверку сходства, вы можете использовать "--disable=all
# --enable=similarities". Если вы хотите запустить только проверку классов, но у вас есть
# Сообщения уровня предупреждения не отображаются, используйте "--disable=all --enable=classes
# --disable=W".
disable=raw-checker-failed,
        bad-inline-option,
        locally-disabled,
        file-ignored,
        suppressed-message,
        useless-suppression,
        deprecated-pragma,
        use-implicit-booleaness-not-comparison-to-string,
        use-implicit-booleaness-not-comparison-to-zero,
        use-symbolic-message-instead,
        C0114,


# Включите сообщение, отчет, категорию или средство проверки с указанными идентификаторами. Ты можешь
# либо укажите несколько идентификаторов, разделенных запятой (,), либо укажите эту опцию
# несколько раз (только в командной строке, а не в файле конфигурации, где
# оно должно появиться только один раз). См. также примеры опции «--disable».
enable=


[METHOD_ARGS]

# Список полных имен (например, Library.method), для которых требуется тайм-аут.
# параметр например 'requests.api.get,requests.api.post'
timeout-methods=requests.api.delete,requests.api.get,requests.api.head,requests.api.options,requests.api.patch,requests.api.post,requests.api.put,requests.api.request


[MISCELLANEOUS]

# Список тегов примечаний, которые следует учитывать, разделенных запятой.
notes=FIXME,
      XXX,
      TODO

# Регулярное выражение тегов заметок, которые следует учитывать.
notes-rgx=


[REFACTORING]

# Максимальное количество вложенных блоков для тела функции/метода
max-nested-blocks=5

# Полное имя функции, которая никогда не возвращает результат. При проверке на
# несогласованный оператор возврата, если вызывается никогда не возвращающая функция, то
# это будет рассматриваться как явный оператор возврата и никакого сообщения не будет
# напечатано.
never-returning-functions=sys.exit,argparse.parse_error


[REPORTS]

# Выражение Python, которое должно возвращать оценку меньше или равную 10. Вы
# иметь доступ к переменным 'fatal', 'error', 'warning', 'refactor',
# 'convention' и 'info', которые содержат количество сообщений в каждом
# категория, а также «оператор», который представляет собой общее количество операторов.
# проанализировано. Эта оценка используется в отчете о глобальной оценке (RP0004).
evaluation=max(0, 0 if fatal else 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10))

# Шаблон, используемый для отображения сообщений. Это строка формата нового стиля Python.
# используется для форматирования информации сообщения. См. документ для всех подробностей.
msg-template=

# Установите выходной формат. Доступные форматы: text, parseable, colorized,
# json2 (improved json format), json (old json format) and msvs (visual
# studio). Вы также можете провести урок репортера, например.
# mypackage.mymodule.MyReporterClass.
#output-format=colorized

# Указывает, отображать ли полный отчет или только сообщения.
reports=no

# Активируйте оценочный балл.
score=yes


[SIMILARITIES]

# Комментарии удаляются из расчета сходства.
ignore-comments=yes

# Строки документации удаляются из расчета сходства.
ignore-docstrings=yes

# Импорт удаляется из расчета сходства.
ignore-imports=yes

# Подписи удаляются из расчета сходства.
ignore-signatures=yes

# Минимальное количество строк сходства.
min-similarity-lines=4


[SPELLING]

# Ограничивает количество выдаваемых предложений по поводу орфографических ошибок.
max-spelling-suggestions=4

# Название словаря орфографии. Нет доступных словарей: необходимо установить.
# как пакет Python, так и системная зависимость для работы enchant.
spelling-dict=

# Список слов, разделенных запятыми, которые следует считать директивами, если они
# появляются в начале комментария и не должны проверяться.
spelling-ignore-comment-directives=fmt: on,fmt: off,noqa:,noqa,nosec,isort:skip,mypy:

# Список слов, разделенных запятыми, которые не следует проверять.
spelling-ignore-words=

# Путь к файлу, содержащему частный словарь; по одному слову в строке.
spelling-private-dict-file=

# Указывает, сохранять ли неизвестные слова в личном словаре (см.
# --spelling-private-dict-file) вместо создания сообщения.
spelling-store-unknown-words=no


[STRING]

# Этот флаг определяет, будут ли несогласованные кавычки генерировать предупреждение, когда
# символ используемый в качестве разделителя кавычек, используется в модуле непоследовательно.
check-quote-consistency=no

# Этот флаг определяет, должен ли неявный-str-concat генерировать предупреждение.
# при неявной конкатенации строк в последовательностях, определенных в нескольких строках.
check-str-concat-over-line-jumps=no


[TYPECHECK]

# Список декораторов, которые создают менеджеры контекста, такие как
# contextlib.contextmanager. Добавьте в этот список, чтобы зарегистрировать других декораторов, которые
# создать действительные менеджеры контекста.
contextmanager-decorators=contextlib.contextmanager

# Список членов, которые задаются динамически и пропускаются при выводе Pylint
# системы и поэтому не должен вызывать E1101 при доступе. Python обычный
# выражения принимаются.
generated-members=

# Сообщает, следует ли предупреждать об отсутствующих членах, когда владелец атрибута
# предполагается, что это None.
ignore-none=yes

# Этот флаг определяет, должен ли pylint предупреждать об отсутствии члена и т.п.
# проверяет каждый раз, когда при выводе возвращается непрозрачный объект. Вывод
# может возвращать несколько потенциальных результатов при оценке объекта Python, но
# некоторые ветви могут не быть оценены, что приводит к частичному выводу. В
# в этом случае было бы полезно по-прежнему выдавать проверки отсутствия членства и другие проверки для
# остальные выведенные объекты.
ignore-on-opaque-inference=yes

# Список имен символических сообщений, которые члены Mixin игнорируют.
ignored-checks-for-mixins=no-member,
                          not-async-context-manager,
                          not-context-manager,
                          attribute-defined-outside-init

# Список имен классов, атрибуты членов которых не следует проверять (полезно
# для классов с динамически устанавливаемыми атрибутами). Это поддерживает использование
# квалифицированные имена.
ignored-classes=optparse.Values,thread._local,_thread._local,argparse.Namespace

# Показывать подсказку с возможными именами, если имя участника не найдено. Аспект
# Поиск подсказки основан на расстоянии редактирования.
missing-member-hint=yes

# Минимальное расстояние редактирования, которое должно иметь имя, чтобы считаться
# аналогичное совпадение для отсутствующего имени участника.
missing-member-hint-distance=1

# Общее количество похожих названий, которые следует учитывать при
# показывает подсказку для отсутствующего члена.
missing-member-max-choices=1

# Шаблон регулярного выражения, определяющий, какие классы считаются примесями.
mixin-class-rgx=.*[Mm]ixin

# Список декораторов, меняющих сигнатуру декорируемой функции.
signature-mutators=


[VARIABLES]

# Список дополнительных имен, которые должны быть определены во встроенных функциях. Помните, что
# вам следует избегать определения новых встроенных функций, когда это возможно.
additional-builtins=

# Указывает, следует ли рассматривать неиспользуемые глобальные переменные как нарушение.
allow-global-unused-variables=yes

# Список имен, которым разрешено скрывать встроенные функции
allowed-redefined-builtins=

# Список строк, которые могут идентифицировать функцию обратного вызова по имени. Обратный вызов
# имя должно начинаться или заканчиваться одной из этих строк.
callbacks=cb_,
          _cb

# Регулярное выражение, соответствующее имени фиктивных переменных (т. е. ожидаемое
# не использоваться).
dummy-variables-rgx=_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_

# Имена аргументов, соответствующие этому выражению, будут игнорироваться.
ignored-argument-names=_.*|^ignored_|^unused_

# Сообщает, следует ли нам проверять наличие неиспользуемого импорта в файлах __init__.
init-import=no

# Список имен квалифицированных модулей, которые могут иметь объекты, которые можно переопределить.
# встроенных функций.
redefining-builtins-modules=six.moves,past.builtins,future.builtins,builtins,io
